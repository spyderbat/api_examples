/*
 * Spyderbat API UI & Public APIs
 *
 * Restful APIs for use by UI & customers.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: apisupport@spyderbat.com
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct MetricsDataQueryInput {
    /// Aggregations
    #[serde(rename = "aggs", skip_serializing_if = "Option::is_none")]
    pub aggs: Option<::std::collections::HashMap<String, serde_json::Value>>,
    #[serde(rename = "causal", skip_serializing_if = "Option::is_none")]
    pub causal: Option<Box<crate::models::RstoreCausalQuery>>,
    /// Context UID for this query, it's used to track the query as it flows through the system, and shouldn't be exposed to customers
    #[serde(rename = "context_uid", skip_serializing_if = "Option::is_none")]
    pub context_uid: Option<String>,
    /// DataType to query
    #[serde(rename = "data_type")]
    pub data_type: String,
    /// Time in unix epoch time, records < time are returned
    #[serde(rename = "end_time", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<f64>,
    #[serde(rename = "expr", skip_serializing_if = "Option::is_none")]
    pub expr: Option<Box<crate::models::Expr>>,
    /// Array of IDs to resolve into records
    #[serde(rename = "ids", skip_serializing_if = "Option::is_none")]
    pub ids: Option<Vec<String>>,
    /// Organization UID to query
    #[serde(rename = "org_uid")]
    pub org_uid: String,
    /// Array of top level object properties which will be emitted, if none are specified all will be emitted
    #[serde(rename = "projection", skip_serializing_if = "Option::is_none")]
    pub projection: Option<Vec<String>>,
    /// Lucene based search query
    #[serde(rename = "query", skip_serializing_if = "Option::is_none")]
    pub query: Option<String>,
    /// Where to start the query in the result set from
    #[serde(rename = "query_from", skip_serializing_if = "Option::is_none")]
    pub query_from: Option<i32>,
    /// Size of the query result set
    #[serde(rename = "query_size", skip_serializing_if = "Option::is_none")]
    pub query_size: Option<i32>,
    #[serde(rename = "return_rptrs", skip_serializing_if = "Option::is_none")]
    pub return_rptrs: Option<bool>,
    #[serde(rename = "rptrs", skip_serializing_if = "Option::is_none")]
    pub rptrs: Option<Vec<String>>,
    /// Sort column
    #[serde(rename = "sort_col", skip_serializing_if = "Option::is_none")]
    pub sort_col: Option<String>,
    /// Sort order
    #[serde(rename = "sort_order", skip_serializing_if = "Option::is_none")]
    pub sort_order: Option<String>,
    /// Source UID to query
    #[serde(rename = "src_uid", skip_serializing_if = "Option::is_none")]
    pub src_uid: Option<String>,
    /// Time in unix epoch time, records >= time are returned
    #[serde(rename = "start_time", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<f64>,
}

impl MetricsDataQueryInput {
    pub fn new(data_type: String, org_uid: String) -> MetricsDataQueryInput {
        MetricsDataQueryInput {
            aggs: None,
            causal: None,
            context_uid: None,
            data_type,
            end_time: None,
            expr: None,
            ids: None,
            org_uid,
            projection: None,
            query: None,
            query_from: None,
            query_size: None,
            return_rptrs: None,
            rptrs: None,
            sort_col: None,
            sort_order: None,
            src_uid: None,
            start_time: None,
        }
    }
}


