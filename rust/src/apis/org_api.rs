/*
 * Spyderbat API UI & Public APIs
 *
 * Restful APIs for use by UI & customers.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: apisupport@spyderbat.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`org_assign_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgAssignRoleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_invite_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgInviteUsersError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgListError {
    Status400(crate::models::ValidationError),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_list_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgListRoleError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_load`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgLoadError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_load_notification_policy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgLoadNotificationPolicyError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_test_notification_target`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgTestNotificationTargetError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_unassign_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgUnassignRoleError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgUpdateError {
    Status400(crate::models::ValidationError),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`org_update_notification_policy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgUpdateNotificationPolicyError {
    Status400(crate::models::ValidationError),
    Status403(),
    UnknownValue(serde_json::Value),
}


///  Assigns a role to a particular user on an organization   * Requires the user have the action *user.AssignRole* on the organization 
pub async fn org_assign_role(configuration: &configuration::Configuration, org_uid: &str, org_assign_role_input: Option<crate::models::OrgAssignRoleInput>) -> Result<(), Error<OrgAssignRoleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}/assignedrole/add", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&org_assign_role_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrgAssignRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Invites users to an organization   * Requires action *org:InviteUsers* on the organization to invite users  
pub async fn org_invite_users(configuration: &configuration::Configuration, org_uid: &str, org_invite_users_input: Option<crate::models::OrgInviteUsersInput>) -> Result<(), Error<OrgInviteUsersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}/invite", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&org_invite_users_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrgInviteUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Lists organizations   * Will list organizations which the user has the action *org:Load* or *org:LoadExpired* on 
pub async fn org_list(configuration: &configuration::Configuration, has_resource_policy: Option<bool>, has_tags: Option<Vec<String>>, include_expired: Option<bool>, name_contains: Option<&str>, owner_uid_equals: Option<&str>, page: Option<i32>, page_size: Option<i32>, uid_equals: Option<&str>) -> Result<Vec<crate::models::Org>, Error<OrgListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = has_resource_policy {
        local_var_req_builder = local_var_req_builder.query(&[("has_resource_policy", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_tags {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("has_tags".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("has_tags", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = include_expired {
        local_var_req_builder = local_var_req_builder.query(&[("include_expired", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name_contains {
        local_var_req_builder = local_var_req_builder.query(&[("name_contains", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = owner_uid_equals {
        local_var_req_builder = local_var_req_builder.query(&[("owner_uid_equals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = uid_equals {
        local_var_req_builder = local_var_req_builder.query(&[("uid_equals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrgListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Allows querying of roles on the organization   * Requires the user have the action *org:ListOrgRoles* on the organization 
pub async fn org_list_role(configuration: &configuration::Configuration, org_uid: &str, role_uid_equals: Option<&str>, user_email_equals: Option<&str>, user_uid_equals: Option<&str>) -> Result<Vec<crate::models::DaoOrgRoleResponse>, Error<OrgListRoleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}/assignedrole/", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = role_uid_equals {
        local_var_req_builder = local_var_req_builder.query(&[("role_uid_equals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_email_equals {
        local_var_req_builder = local_var_req_builder.query(&[("user_email_equals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_uid_equals {
        local_var_req_builder = local_var_req_builder.query(&[("user_uid_equals", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrgListRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Loads an organization by UID.    * Requires action *org:Load*  * Requires action *org:LoadExpired* to load expired organizations  
pub async fn org_load(configuration: &configuration::Configuration, org_uid: &str) -> Result<crate::models::Org, Error<OrgLoadError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrgLoadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Loads the notification policy for an organization. The notification policy defines who and how the organization is notified.     * If the content-type is application/hjson the policy will be returned as hjson  * If the content-type is application/json the policy will be returned as json    * Requires the user have the action *org:LoadNotificationPolicy* on the organization 
pub async fn org_load_notification_policy(configuration: &configuration::Configuration, org_uid: &str) -> Result<crate::models::NotificationPolicy, Error<OrgLoadNotificationPolicyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}/notification_policy/", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<OrgLoadNotificationPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Sends a test notification to a target.   * Requires the user have the action *org:SendTestNotification* on the organization 
pub async fn org_test_notification_target(configuration: &configuration::Configuration, org_uid: &str, org_test_notification_target_input: Option<crate::models::OrgTestNotificationTargetInput>) -> Result<(), Error<OrgTestNotificationTargetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}/notification_policy/test_target", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&org_test_notification_target_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrgTestNotificationTargetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Unassigns a role to a particular user on an organization   * Requires the user have the action *user.UnassignRole* on the organization 
pub async fn org_unassign_role(configuration: &configuration::Configuration, org_uid: &str, org_unassign_role_input: Option<crate::models::OrgUnassignRoleInput>) -> Result<(), Error<OrgUnassignRoleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}/assignedrole/del", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&org_unassign_role_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrgUnassignRoleError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Updates the organization    * Requires the user have the action *org:Update* on the organization 
pub async fn org_update(configuration: &configuration::Configuration, org_uid: &str, org_update_input: Option<crate::models::OrgUpdateInput>) -> Result<(), Error<OrgUpdateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&org_update_input);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrgUpdateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Updates the organization's notification policy  The policy contains targets, which are named destinations, for example a list of admins, and then rules for how notifications are routed. The most basic notification is the default policy assigned to all organizations, which is to send notifications to the organization owner.   Each notification has a schema which can be used to filter how notifications are routed.   Here is an example notification policy:  ``` {     \"targets\": {       \"admins\": {         \"emails\": [           \"admin1@foo.com\",           \"admin2@foo.com\"         ]       },       \"soc\": {         \"slack\": {           \"url\": \"http://app.slack.com/XXXX\"         }       },       \"sns_example\": {         \"data\": \"UI supplied data\",         \"description\": \"Cross-Account Notification\",         \"sns\": {           \"sns_topic_arn\": \"arn:aws:sns:CUSTOMER-AWS-REGION:CUSTOMER-AWS-ACCOUNT-ID:CUSTOMER-TOPIC-NAME\",           \"cross_account_iam_role\": \"arn:aws:iam::CUSTOMER-ACCOUNT-ID:role/CUSTOMER-ROLE-NAME\"         }       }     },     \"routes\": [       {         \"target\": \"admins\",         \"expr\": {           \"schema\": \"agent_offline\"         }       },       {         \"target\": \"soc\",         \"expr\": {           \"schema\": \"spydertrace_updated\"         }       },       {         \"destination\": {           \"users\": [             \"X23hs8234lks\"           ]         }       }     ]   } ```  This policy says that any notification with the schema \"agent_offline\" is send to the admin emails, and that any notifications with the schema \"spydertrace_update\" is send to the soc slack channel, and all other notifications are sent to a user specified by their UserUID. If a destination is an explicit UserUID then the users notification policy will applied, for example to notify them by their notification type of choice.     * The following destination types are currently supported, UserUID, Email, Slack, Webhook, SNS. See the associated destination definition in the notification policy for details.   * First match for a routing rule wins, and further processsing of the notification stops.   * If a UserUID is specified the users notification policy may be used to contact that user.  * Each notification has an associated schema, which is used to provide a consistent schema for the notification.  * Expressions are optional, if no expression is specified the route matches by default  * If the content-type is application/hjson the policy will be parsed and stored as hjson, all comments will be lost on an existing hjson policy if it is uploaded as json  This is an example notification generated using a notification policy and dashboardsearch:  ``` {  \"uid\": \"lQ0Q1lKm\",  \"org_uid\": \"your_org_uid\",  \"valid_from\": \"2021-10-14T19:22:00.869159169Z\",  \"title\": \"Spyderbat: Dashboard search notification Recent interactive (shell) Processes\",  \"message\": \"Spyderbat: Dashboard search notification Recent interactive (shell) Processes\",  \"data\": {    \"dashboardsearch\": {   \"data\": {     \"createTime\": 1634237497.142,     \"createdBy\": \"user@example.com\"   },   \"description\": \"Recent interactive (shell) Processes\",   \"notify\": true,   \"notify_frequency\": 300,   \"org_uid\": \"spyderbatuid\",   \"search\": \"schema:model_process AND interactive:true\",   \"uid\": \"RTBQoR3uucyjG8ZeHJmw\"    }  },  \"schema\": \"dashboard_saved_search\",  \"records\": [    {   \"total_hits\": 0    }  ]   } ```   * Requires the user have the action *org:UpdateNotificationPolicy* on the organization 
pub async fn org_update_notification_policy(configuration: &configuration::Configuration, org_uid: &str, notification_policy: crate::models::NotificationPolicy) -> Result<(), Error<OrgUpdateNotificationPolicyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/org/{orgUID}/notification_policy", local_var_configuration.base_path, orgUID=crate::apis::urlencode(org_uid));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notification_policy);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<OrgUpdateNotificationPolicyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

