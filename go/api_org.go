/*
Spyderbat API UI & Public APIs

Restful APIs for use by UI & customers.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sbapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// OrgApiService OrgApi service
type OrgApiService service

type ApiOrgAssignRoleRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
	orgAssignRoleInput *OrgAssignRoleInput
}

func (r ApiOrgAssignRoleRequest) OrgAssignRoleInput(orgAssignRoleInput OrgAssignRoleInput) ApiOrgAssignRoleRequest {
	r.orgAssignRoleInput = &orgAssignRoleInput
	return r
}

func (r ApiOrgAssignRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrgAssignRoleExecute(r)
}

/*
OrgAssignRole Assign OrgRole


Assigns a role to a particular user on an organization

 * Requires the user have the action *user.AssignRole* on the organization


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgAssignRoleRequest
*/
func (a *OrgApiService) OrgAssignRole(ctx context.Context, orgUID string) ApiOrgAssignRoleRequest {
	return ApiOrgAssignRoleRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
func (a *OrgApiService) OrgAssignRoleExecute(r ApiOrgAssignRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgAssignRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}/assignedrole/add"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orgAssignRoleInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrgInviteUsersRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
	orgInviteUsersInput *OrgInviteUsersInput
}

func (r ApiOrgInviteUsersRequest) OrgInviteUsersInput(orgInviteUsersInput OrgInviteUsersInput) ApiOrgInviteUsersRequest {
	r.orgInviteUsersInput = &orgInviteUsersInput
	return r
}

func (r ApiOrgInviteUsersRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrgInviteUsersExecute(r)
}

/*
OrgInviteUsers Invite users to an organization


Invites users to an organization

 * Requires action *org:InviteUsers* on the organization to invite users



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgInviteUsersRequest
*/
func (a *OrgApiService) OrgInviteUsers(ctx context.Context, orgUID string) ApiOrgInviteUsersRequest {
	return ApiOrgInviteUsersRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
func (a *OrgApiService) OrgInviteUsersExecute(r ApiOrgInviteUsersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgInviteUsers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}/invite"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orgInviteUsersInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrgListRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	hasResourcePolicy *bool
	hasTags *[]string
	includeExpired *bool
	nameContains *string
	ownerUidEquals *string
	page *int32
	pageSize *int32
	uidEquals *string
}

func (r ApiOrgListRequest) HasResourcePolicy(hasResourcePolicy bool) ApiOrgListRequest {
	r.hasResourcePolicy = &hasResourcePolicy
	return r
}

func (r ApiOrgListRequest) HasTags(hasTags []string) ApiOrgListRequest {
	r.hasTags = &hasTags
	return r
}

func (r ApiOrgListRequest) IncludeExpired(includeExpired bool) ApiOrgListRequest {
	r.includeExpired = &includeExpired
	return r
}

func (r ApiOrgListRequest) NameContains(nameContains string) ApiOrgListRequest {
	r.nameContains = &nameContains
	return r
}

func (r ApiOrgListRequest) OwnerUidEquals(ownerUidEquals string) ApiOrgListRequest {
	r.ownerUidEquals = &ownerUidEquals
	return r
}

func (r ApiOrgListRequest) Page(page int32) ApiOrgListRequest {
	r.page = &page
	return r
}

func (r ApiOrgListRequest) PageSize(pageSize int32) ApiOrgListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiOrgListRequest) UidEquals(uidEquals string) ApiOrgListRequest {
	r.uidEquals = &uidEquals
	return r
}

func (r ApiOrgListRequest) Execute() ([]Org, *http.Response, error) {
	return r.ApiService.OrgListExecute(r)
}

/*
OrgList List organizations


Lists organizations

 * Will list organizations which the user has the action *org:Load* or *org:LoadExpired* on


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrgListRequest
*/
func (a *OrgApiService) OrgList(ctx context.Context) ApiOrgListRequest {
	return ApiOrgListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Org
func (a *OrgApiService) OrgListExecute(r ApiOrgListRequest) ([]Org, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Org
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hasResourcePolicy != nil {
		localVarQueryParams.Add("has_resource_policy", parameterToString(*r.hasResourcePolicy, ""))
	}
	if r.hasTags != nil {
		t := *r.hasTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("has_tags", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("has_tags", parameterToString(t, "multi"))
		}
	}
	if r.includeExpired != nil {
		localVarQueryParams.Add("include_expired", parameterToString(*r.includeExpired, ""))
	}
	if r.nameContains != nil {
		localVarQueryParams.Add("name_contains", parameterToString(*r.nameContains, ""))
	}
	if r.ownerUidEquals != nil {
		localVarQueryParams.Add("owner_uid_equals", parameterToString(*r.ownerUidEquals, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.uidEquals != nil {
		localVarQueryParams.Add("uid_equals", parameterToString(*r.uidEquals, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrgListRoleRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
	roleUidEquals *string
	userEmailEquals *string
	userUidEquals *string
}

func (r ApiOrgListRoleRequest) RoleUidEquals(roleUidEquals string) ApiOrgListRoleRequest {
	r.roleUidEquals = &roleUidEquals
	return r
}

func (r ApiOrgListRoleRequest) UserEmailEquals(userEmailEquals string) ApiOrgListRoleRequest {
	r.userEmailEquals = &userEmailEquals
	return r
}

func (r ApiOrgListRoleRequest) UserUidEquals(userUidEquals string) ApiOrgListRoleRequest {
	r.userUidEquals = &userUidEquals
	return r
}

func (r ApiOrgListRoleRequest) Execute() ([]DaoOrgRoleResponse, *http.Response, error) {
	return r.ApiService.OrgListRoleExecute(r)
}

/*
OrgListRole List OrgRoles


Allows querying of roles on the organization

 * Requires the user have the action *org:ListOrgRoles* on the organization


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgListRoleRequest
*/
func (a *OrgApiService) OrgListRole(ctx context.Context, orgUID string) ApiOrgListRoleRequest {
	return ApiOrgListRoleRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
//  @return []DaoOrgRoleResponse
func (a *OrgApiService) OrgListRoleExecute(r ApiOrgListRoleRequest) ([]DaoOrgRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DaoOrgRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgListRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}/assignedrole/"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return localVarReturnValue, nil, reportError("orgUID must have less than 64 elements")
	}

	if r.roleUidEquals != nil {
		localVarQueryParams.Add("role_uid_equals", parameterToString(*r.roleUidEquals, ""))
	}
	if r.userEmailEquals != nil {
		localVarQueryParams.Add("user_email_equals", parameterToString(*r.userEmailEquals, ""))
	}
	if r.userUidEquals != nil {
		localVarQueryParams.Add("user_uid_equals", parameterToString(*r.userUidEquals, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrgLoadRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
}

func (r ApiOrgLoadRequest) Execute() (*Org, *http.Response, error) {
	return r.ApiService.OrgLoadExecute(r)
}

/*
OrgLoad Load an organization


Loads an organization by UID. 

 * Requires action *org:Load*
 * Requires action *org:LoadExpired* to load expired organizations



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgLoadRequest
*/
func (a *OrgApiService) OrgLoad(ctx context.Context, orgUID string) ApiOrgLoadRequest {
	return ApiOrgLoadRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
//  @return Org
func (a *OrgApiService) OrgLoadExecute(r ApiOrgLoadRequest) (*Org, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Org
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgLoad")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return localVarReturnValue, nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrgLoadNotificationPolicyRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
}

func (r ApiOrgLoadNotificationPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrgLoadNotificationPolicyExecute(r)
}

/*
OrgLoadNotificationPolicy Load Notification Policy


Loads the notification policy for an organization. The notification policy defines who and how the organization is notified. 
 
 * If the content-type is application/hjson the policy will be returned as hjson
 * If the content-type is application/json the policy will be returned as json


 * Requires the user have the action *org:LoadNotificationPolicy* on the organization


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgLoadNotificationPolicyRequest
*/
func (a *OrgApiService) OrgLoadNotificationPolicy(ctx context.Context, orgUID string) ApiOrgLoadNotificationPolicyRequest {
	return ApiOrgLoadNotificationPolicyRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
func (a *OrgApiService) OrgLoadNotificationPolicyExecute(r ApiOrgLoadNotificationPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgLoadNotificationPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}/notification_policy/"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrgTestNotificationTargetRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
	orgTestNotificationTargetInput *OrgTestNotificationTargetInput
}

func (r ApiOrgTestNotificationTargetRequest) OrgTestNotificationTargetInput(orgTestNotificationTargetInput OrgTestNotificationTargetInput) ApiOrgTestNotificationTargetRequest {
	r.orgTestNotificationTargetInput = &orgTestNotificationTargetInput
	return r
}

func (r ApiOrgTestNotificationTargetRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrgTestNotificationTargetExecute(r)
}

/*
OrgTestNotificationTarget Test Notification Target


Sends a test notification to a target.

 * Requires the user have the action *org:SendTestNotification* on the organization


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgTestNotificationTargetRequest
*/
func (a *OrgApiService) OrgTestNotificationTarget(ctx context.Context, orgUID string) ApiOrgTestNotificationTargetRequest {
	return ApiOrgTestNotificationTargetRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
func (a *OrgApiService) OrgTestNotificationTargetExecute(r ApiOrgTestNotificationTargetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgTestNotificationTarget")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}/notification_policy/test_target"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orgTestNotificationTargetInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrgUnassignRoleRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
	orgUnassignRoleInput *OrgUnassignRoleInput
}

func (r ApiOrgUnassignRoleRequest) OrgUnassignRoleInput(orgUnassignRoleInput OrgUnassignRoleInput) ApiOrgUnassignRoleRequest {
	r.orgUnassignRoleInput = &orgUnassignRoleInput
	return r
}

func (r ApiOrgUnassignRoleRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrgUnassignRoleExecute(r)
}

/*
OrgUnassignRole Unassign OrgRole


Unassigns a role to a particular user on an organization

 * Requires the user have the action *user.UnassignRole* on the organization


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgUnassignRoleRequest
*/
func (a *OrgApiService) OrgUnassignRole(ctx context.Context, orgUID string) ApiOrgUnassignRoleRequest {
	return ApiOrgUnassignRoleRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
func (a *OrgApiService) OrgUnassignRoleExecute(r ApiOrgUnassignRoleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgUnassignRole")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}/assignedrole/del"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orgUnassignRoleInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrgUpdateRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
	orgUpdateInput *OrgUpdateInput
}

func (r ApiOrgUpdateRequest) OrgUpdateInput(orgUpdateInput OrgUpdateInput) ApiOrgUpdateRequest {
	r.orgUpdateInput = &orgUpdateInput
	return r
}

func (r ApiOrgUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrgUpdateExecute(r)
}

/*
OrgUpdate Update an organization


Updates the organization 

 * Requires the user have the action *org:Update* on the organization


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID Org UID
 @return ApiOrgUpdateRequest
*/
func (a *OrgApiService) OrgUpdate(ctx context.Context, orgUID string) ApiOrgUpdateRequest {
	return ApiOrgUpdateRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
func (a *OrgApiService) OrgUpdateExecute(r ApiOrgUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orgUpdateInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrgUpdateNotificationPolicyRequest struct {
	ctx context.Context
	ApiService *OrgApiService
	orgUID string
}

func (r ApiOrgUpdateNotificationPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrgUpdateNotificationPolicyExecute(r)
}

/*
OrgUpdateNotificationPolicy Update an organization's notification policy


Updates the organization's notification policy

The policy contains targets, which are named destinations, for example a list of admins, and then rules for how notifications
are routed. The most basic notification is the default policy assigned to all organizations, which is to send notifications
to the organization owner. 

Each notification has a schema which can be used to filter how notifications are routed. 

Here is an example notification policy:

```
{
    "targets": {
      "admins": {
        "emails": [
          "admin1@foo.com",
          "admin2@foo.com"
        ]
      },
      "soc": {
        "slack": {
          "url": "http://app.slack.com/XXXX"
        }
      },
      "sns_example": {
        "data": "UI supplied data",
        "description": "Cross-Account Notification",
        "sns": {
          "sns_topic_arn": "arn:aws:sns:CUSTOMER-AWS-REGION:CUSTOMER-AWS-ACCOUNT-ID:CUSTOMER-TOPIC-NAME",
          "cross_account_iam_role": "arn:aws:iam::CUSTOMER-ACCOUNT-ID:role/CUSTOMER-ROLE-NAME"
        }
      }
    },
    "routes": [
      {
        "target": "admins",
        "expr": {
          "schema": "agent_offline"
        }
      },
      {
        "target": "soc",
        "expr": {
          "schema": "spydertrace_updated"
        }
      },
      {
        "destination": {
          "users": [
            "X23hs8234lks"
          ]
        }
      }
    ]
  }
```

This policy says that any notification with the schema "agent_offline" is send to the admin emails, and that any notifications with the schema "spydertrace_update" is send to the soc slack channel, and all other notifications are sent to a user specified by their UserUID. If a destination is an explicit UserUID then the users notification policy will applied, for example to notify them by their notification type of choice.  

 * The following destination types are currently supported, UserUID, Email, Slack, Webhook, SNS. See the associated destination definition in the notification policy for details. 
 * First match for a routing rule wins, and further processsing of the notification stops. 
 * If a UserUID is specified the users notification policy may be used to contact that user.
 * Each notification has an associated schema, which is used to provide a consistent schema for the notification.
 * Expressions are optional, if no expression is specified the route matches by default
 * If the content-type is application/hjson the policy will be parsed and stored as hjson, all comments will be lost on an existing hjson policy if it is uploaded as json

This is an example notification generated using a notification policy and dashboardsearch:

```
{
	"uid": "lQ0Q1lKm",
	"org_uid": "your_org_uid",
	"valid_from": "2021-10-14T19:22:00.869159169Z",
	"title": "Spyderbat: Dashboard search notification Recent interactive (shell) Processes",
	"message": "Spyderbat: Dashboard search notification Recent interactive (shell) Processes",
	"data": {
	  "dashboardsearch": {
		"data": {
		  "createTime": 1634237497.142,
		  "createdBy": "user@example.com"
		},
		"description": "Recent interactive (shell) Processes",
		"notify": true,
		"notify_frequency": 300,
		"org_uid": "spyderbatuid",
		"search": "schema:model_process AND interactive:true",
		"uid": "RTBQoR3uucyjG8ZeHJmw"
	  }
	},
	"schema": "dashboard_saved_search",
	"records": [
	  {
		"total_hits": 0
	  }
	]
  }
```

 * Requires the user have the action *org:UpdateNotificationPolicy* on the organization


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgUID
 @return ApiOrgUpdateNotificationPolicyRequest
*/
func (a *OrgApiService) OrgUpdateNotificationPolicy(ctx context.Context, orgUID string) ApiOrgUpdateNotificationPolicyRequest {
	return ApiOrgUpdateNotificationPolicyRequest{
		ApiService: a,
		ctx: ctx,
		orgUID: orgUID,
	}
}

// Execute executes the request
func (a *OrgApiService) OrgUpdateNotificationPolicyExecute(r ApiOrgUpdateNotificationPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgApiService.OrgUpdateNotificationPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/org/{orgUID}/notification_policy"
	localVarPath = strings.Replace(localVarPath, "{"+"orgUID"+"}", url.PathEscape(parameterToString(r.orgUID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.orgUID) > 64 {
		return nil, reportError("orgUID must have less than 64 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
